<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
</head>

<body>
<input type="text" id="ui-input" />
<script>
/*******
1.对象直接量----{}
2.数组直接量---[]
3.正则直接量---//
4.new运算符,创建指定类的对象实例
5.in 检查对象属性
6.instanceof 检查变量是否是指定类的实例
7.delete 删除实例属性
8.'.'和['propName']运算符存取对象成员(属性、方法)
9.for...in...列举对象成员
10.with 设定语句默认对象
*******/
/*******
delete 可以删除对象成员和数组元素，但不能删除：
	1.用var声明的变量;
	2.直接继承自原型的成员。
Case:
var obj = {
		type: 'post',
		url: '//www.baidu.com',
		status: true,
		name: 'obj01',
		innerObj: {
			name: 'innerName',
			status: false,
			url: '//inner.baidu.com',
			type: 'get',
			getName: function() {
				console.dir(this.name);	
			}	
		},
		isBoolean: function() {
			console.dir('False');	
		}
	}
	with(obj){
		console.dir(typeof innerObj);
		if(typeof innerObj === 'object') {
			with(innerObj) {
				console.dir(getName);	
			}	
		}
	}
*******/
/******
function foo() {
	this.name = 'wrappername';
	this.age = 29;
	var data = this;
	console.dir(this);
	return {
			name: 'zhux',
			age: 28,
			getName: function() {
				console.dir(this);
			}
		};	
}
var obj = new foo;
obj.getName.call(foo,null);


function MyObject() {
	
}
MyObject.prototype.value = 100;
var obj01 = new MyObject();
var obj02 = new MyObject();
	obj03 = new MyObject();
delete obj01.value;
delete obj01.constructor.prototype.value;
delete obj03;
console.dir(obj03);

var obj = {
		isArray: function ( obj ) {
			return typeof obj === 'object' || typeof obj === 'string' || typeof obj === 'function' || Object.prototype.toString.call( obj ) === '[object Array]'	
		},
		name: 'zhus'
	}
	var arr = [];
		console.dir(Object.prototype.toString.call(arr));
		console.log(obj.isArray(arr));
	console.dir('name' in obj);
	
	if( window.XMLHttpRequest ) {
		return new XMLHttpRequest();	
	}else if( window.ActiveXObject ) {
		return new ActiveXObject('Microsoft.XMLHTTP');	
	}else{
		throw new Error('can\' init ajax system....'):	
	}
	
	
	if( window.XMLHttpRequest ) {
		return new XMLHttpRequest();	
	}else if( window.ActiveXObject ) {
		return new ActiveXObject('Microsoft.XMLHTTP'):	
	}else{
		throw new Error("can't init ajax system....");	
	}
var obj = {};
function _in(obj, prop) {
	if(obj[prop]) {
		return true;	
	}else{
		return false;
	}
}

var propertyNames = [0, '', [], false, undefined, null];
for(var i=0; i<propertyNames.length; i++) {
	alert(_in(obj, propertyNames[i]));			
}


a = 1,2,3;
console.log(a);
alert( eval('a=(1,2,3);') );
alert( eval('a=1,2,3;') );
var table = [
	['A', 1, [1, 2, 3, 4], 3]
	['B', 3, 4, 2]
	[3],
	['C', 5, 6, 7]
];
console.log( table );
alert( i=100, i*=2, 'value: ' + i );
过程式风格仍与能够解释运行程序的计算机显为接近。计算机的显著特性是内存，其中各个单元可以单独更新，它与程序设计语言中的变量正好对应。
面向对象风格是基于过程式风格的。它是后者的一个变种，差别并不太大。尽管过程现在称为“方法”，调 用一个过程现在表述为“发送一条消息”。
JavaScript的非函数式语言特性
命令式来自于命令和动作，这种计算模型就是基于基础机器的一系列动作。《程序设计语言概念和结构》.Ravi Sethi.
概述：
计算机语言的分类：
	1.命令式语言
	2.函数式语言
	3.逻辑式语言
	4.面向对象程序设计语言
JavaScript语言精髓中对语言的分类总结：
	1.命令式语言
	2.说明式语言
	基上演生出对JavaScript的非函数式语言特性。
	
	结构化程序设计中，结构化分为两个部分：
	1.程序的控制结构
		1.顺序、分支和循环三种基本逻辑;
	2.数据结构
		1.基本数据结构和复合数据结构，且复合数据结构必然由基本数据结构按复合规则构成。
		
	命令式语言的核心就在于：通过运算去改变内存（中的数据），软件程序与硬件系统在本质上就存在如此亲密的关系。
	命令式语言的实质是面向存储的编程。
	计算机的灵魂，及经典法则：程序=算法+结构。
	命令式语言首先关注的也是“数据结构”。
	
	自然语义   --->机器系统--->编程系统--->语言、类型系统
	基本数据单元--->16/32/64位系统--->位/字节/字/双字--->bit/byte/word/dword/...
	连续数据块  --->连续存储块--->数组/字符串/结构体--->array/string/struct/...
	有关系的数据片断--->存储地址--->指针/结构/引用--->pointer/tree/....


function searchInTableTd( value, tableTds ) {
	for( var i=0; i<tableIds.length; i++) {
		if( tableTds[i].value = value ) return true;
	}
	return false;	
}

var a = 0;
do{
	console.dir(a++);
}while(a<10)
while(a<10) {
	console.dir(a++);	
}

变量或成员的可见性，称为作用域，包括语法作用域和变量作用域。



function foo() {
	var a;
	alert(a);
	a = 10;	
	
}
foo();

function MyObject() {
	var data = 100;
		function _run( v ) {
			alert( v );	
		}	
		this.value = 'The data is ....';
		this.run = function() {
			
			_run( this.value + data );	
		}
}
console.log(MyObject.prototype.constructor);
var myobj = new MyObject();
	myobj.run();

function Bird() {
	var bird = (arguments.length == 1 ? arguments[0] : this);
	bird.wing = 2;
	bird.tweet = function() {};
	bird.fly = function() {
		console.log( 'I can fly...' );	
	}	
	return bird;
}	

function Ostrich() {
	this.fly = function() {
		console.log('I can\'t fly...');	
	}	
}
Ostrich.prototype = new Bird();
Ostrich.prototype.constructor = Ostrich;

var ostrich = new Ostrich();
function doFly( bird ) {
	if(bird instanceof Bird) {
		bird.fly();	
	}else{
		throw new Error('I can\' fly....');
	}	
}

doFly( ostrich );


var mobj = new Object();
var bird = Bird( mobj );
	bird.fly();
	mobj.fly();
	console.log( mobj );
	console.log( bird );
	console.log( bird instanceof Object );

经常在浏览器中使用的OnLoad、OnClick 这样的事件，
其实是由DOM：一个由引擎宿主供应与维护的可编程对象模型来提供的。事件并非JavaScript引擎的一个组成部分。
事件的本质，仅仅是“在确定的时候发生的、可由用户代码响应的行为”而已。

function MyObject() {}
MyObject.prototype.OnError = undefined;
MyObject.prototype.doAction = function( str ) {
	try {
		return eval( str );	
	}catch( e ) {
		if( this.OnError) this.OnError( e );	
	}	
}
var obj = new MyObject();
	obj.OnError = function( e ) {
		console.warn( e );
		return;	
	}
	obj.doAction('a.a = 10');
	



extend = function( subClass, baseClass ) {
	subClass.baseConstructor = baseClass;
	subClass.base = {};
	baseClass.call( subClass.base );	
}


function Mouse() {}


function Animal( name ) {
	this.name = name;
	this.say = function( message ) { alert( this.name + ": " + message ); }
	this.eat = function() { this.say( 'Yum!' );	}	
}


function Cat() {
	Cat.baseConstructor.call( this, 'cat' );
	this.eat = function( food ) {
		if( food instanceof Mouse ) { 
			Cat.base.eat.call( this ); 
		}else{ 
			this.say( 'Yuk! I only eat mice - not ' + food.name ); 
		}
	}	
}
	extend( Cat, Animal );

	function Lion() { Lion.baseConstructor.call( this, 'lion' ); }

	extend( Lion, Cat );

var cat = new Cat();
var lion = new Lion();
var mouse = new Mouse();

var unknowObj = {};

	cat.eat( mouse );
	cat.eat( unknowObj );
	lion.eat( mouse );
	console.log( lion instanceof Animal );
	console.log( cat instanceof Animal );
	console.log( cat instanceof Cat );
	console.log( lion instanceof Cat );
	console.log( lion instanceof Lion );
	如何选择继承方式：
	1.类抄写时成员访问效率更高，但内在战胜较大;而原型继承反之。
	2.类抄写不依赖内部原型链来维护继承关系，因此也不能通过instanceof 来做这种检测;原型继承却可以在new 运算时维护这种继承关系，也可以检测之。
	3.JavaScript 应用的环境已经发生了非常多的改变，例如 Flash 中的ActionScript、 Windows 中的 WSH、 Mozilla 中的 XUL／XBL，甚至在一些特殊的商用系统中我们也可以看到 JavaScript 来做控制语言（例如 Acrobat 和Symantec 等公司的产品中对 JavaScript 的应用） 。在这样的局面下， JavaScript
语言这种互补的特性产生了非凡的效用：一方面具有了构建大型对象系统的能力，另一方面也易于快速组织小功能构件（例如 Gadget） 
	4.函数式语言的函数可以保存内部数据的状态。
	5.函数内的运算对函数外无副作用
		1.函数使用入口参数进行运算
		2.在去处过程中不会修改函数外部的其它数据的值
		3.运算结束后通过函数返回向外部系统传值
	
	
var cls;
var objType = getFormInput();
switch( objType ) {
	case 'String': {
		cls = String;
		break;	
	}	
	case 'Number': {
		cls = Number;
		break;	
	}
	default: {
		cls = Object;	
	}
}	
var obj = new cls();
var obj = new Object();



var objType = getFormInput();

var fac = new Factiory();
function Factiory() {
	this.getClass = function( args ) {
		var result = [];
		for( var i=0; i<Array.prototype.slice.call(args,null).length; i++) {
				result.push(args[i].value);
		}
		return function() {
				
		}	
	}	
}
var cls = fac.getClass(objType);

var obj = new cls():
'string', 'number', 'object', 'undefined'



******/
	
</script>
</body>
</html>
